-type of priority queue
minHeap->minimum element at top
remove()->remove that element and do the rearrangement to add the lowest element on the top
add()->add the element and do the rearrangement
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(10);
pq.add(20);
pq.add(30);
pq.remove(); //remove the top most element
System.out.print(pq); //[20,30]
pq.peek(); //20 the min element will be printed, the top element
pq.size(); //2
adding element: O(logn)
removing element: O(logn)
if we are adding 'n' element one by one in heap then no. of operations =log(1)+log(2)+...log(n)
hence : O(nlogn)

MINHEAP v/s ARRAYLIST:
add(2)
add(10)
add(1)
remove()
add(0)
 making a heap using arraylist takes O(nlogn) TC.

MAXHEAP
PriorityQueue<Integer> pq= new PriorityQueue<>(Collections.reverseOrder());

Problem identification:
1) kth smallest/largest/closest/frequent/ k sorted array out of n, if we are working on k elemenet
2) to get better TC
3) minimize maximize continuous sorting

Find kth smallest element in given array:
- if we use minheap-> O(nlogn) for adding element, and O(klogn) to remove k-1 elemnts
public class Solution
{
public static void kth(int nums[],int k)
{
  PriorityQueue<Integer> pq = new PriorityQueue<>();
  for(int ele:nums)
  {
    pq.add(ele);
  }
int n=nums.length;
  for(int i=1;i<k-1;i++)
{
  pq.remove();
}
System.out.print(pq.peek());

}}-->but the time complezity is O(nlogn)

class Solution
{
public void kthSmallest(int[]nums,int k)
{
  PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
  for(int ele:nums)
  {
  pq.add(ele);
  if(pq.size()>k) pq.remove();
    }
System.out.print(pq.peek());
}} -->TC: O(nlogk) better than nlogn

find kth largest element in a given array
class Solution
{
public void kthLargest(int[]nums,int k)
{
  PriorityQueue<Integer> pq = new PriorityQueue<>();
  for(int ele:nums)
  {
  pq.add(ele);
  if(pq.size()>k) pq.remove();
  }
System.out.print(pq.peek());
}}

INTERVIEW QUESTION:
sort a k sorted array(sort nearly sorted array)
arr{6,5,3,2,8,10,9} k=3
-every element is either sorted in its correct position or at max k distance far from its 
sorted positioneither from right side or from left side

{6,5,3,2,8,10,9}
{2,3,5,6,8,9,10}

-make a minheap
-add elements in the minheap,whenever the size becomes greater than k+1 add the topmost 
element in ans[]
-then add the remaining elements in ans

class Solution
{
public void partialsort(int[]nums,int k)
{
  PriorityQueue<Integer> pq = new PriorityQueue<>();
  List<Integer> ans = new ArrayList<>();
  for(int ele: nums)
  {
    pq.add(ele);
  if(pq.size()>k) ans.add(pq.remove());
  }
  while(pq.size()>0)
    {
      ans.add(pq.remove());
    }
}}

if adding an object in priority use use comparable

Leetcode 658
arr={7,8,18,4,9,6} k=3 x=8
-8 se close jitne bhi no., 3 sabse zyada paas
=7,8,9
-absolute diff=> store and min abs dist to be returned
-not neceessary x belongs to array
-if abs becomes same-> a is closer to x if |x-a|<|x-b| and if 
|x-a|==|x-b| then if a<b then a is closer
-travel in array 
-insert no. and diff from x in heap
-MaxHeapfo

//Leetcode 347:
-return those elements which come in the array maximum no. of times
-make a hashmap-> store element and its freq
-in the ques its given each distinct element has a unique freq
-traverse in ele-> store ele,freq in hashmap: O(n)
-the elements in hashmap is considered as a pair and is added in k size minheap

//Leetcode 1046
-method-1: use arraylist and sorting
-at every step we are taking out 2 largest elements=> use maxheap
-add elements in heap
-we have at max n elements in heap so insertion and removal will take log n time
-while heap not empty: remove 2 elements and add the diffrence between the 2 elements in the heap
the element in last will be ans
-TC:O(nlogn)

Minimum cost to connect all ropes:
arr={2,7,4,1,8}
-I can connect 2 ropes at a time and the cost of joing is sum of length of ropes
-2 samllest rope connected and added in the heap
2 7 4 1 8
(2+1)-> 3 7 4 8
(3+4)-> 7 7 8
(7+7)-> 14+8 =22

public int minCost(int nums[])
{
   PriorityQueue<Integer> pq = new PriorityQueue<>();
   for(int i=0;i<nums.length;i++)
   {
     pq.add(nums[i]);
   }
int cost=0;
  while(!pq.isEmpty())
{
   int a= pq.remove();
   int b=pq.remove();
   int c=a+b;
    pq.add(c);
  cost+=c;
}
return cost;
}

//Leetcode 373:
-maxheap 
-travesrse in 2 arrays ans insert in the maxheap
-make a Pair and sum
-insert until size<k
-when the size becomes k 

Questions:
Leetcode 973
Leetcode 658
Leetcode 347
Leetcode 1636 
Leetcode 1046
Leetcode 703
Leetcode 373

<use the notes pw>
TO do:
Leetcode 767
Leetcode 451
Leetcode 1405
Leetcode 1642
Leetcode 1054
Leetcode 2182
Leetcode 2208
Leetcode 1383
Leetcode 23
Leetcode 480
Leetcode 1354
Leetcode 1439
Leetcode 295
