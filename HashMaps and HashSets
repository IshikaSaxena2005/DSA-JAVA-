HASHSET
-type of datastructure
-TC:O(1):searching

import java.util.HashSet;
public class basic
{
public static void main(String[]args)
{
HashSet<Integer> set = new HashSet<>(); //this integer is a wrapper class of int
set.add(10);
set.add(20);
set.add(30);
//adding TC:O(1)
System.out.println(set);
//the elements are inserted in random order inside the set
//printed in random order
//search an element
System.out.print(set.contains(10)); // return true or false //TC:O(1)
System.out.print(set.size()); //3 TC:O(1)
set.remove(30);  //TC:O(1)
System.out.print(set); //10,20
Object[] arr= set.toArray();
for(int i=0;i<arr.length;i++)
{
  System.out.print(arr[i]+"");
}}}

For iteration in Hashset: using for each loop
for(int ele:set)
{
 System.out.print(ele);
set.add(30); //not possible 
}
//during iteration we cannnot add or remove elements
set.clear();  //empty set
//in hashset, occurance of any element is 1
//no element is repeated in set

HashSet<String> srt= new HashSet<>();

find max reverse pairs:
make a set
make a variable count
iterate in words see for each rev=reverse(words[i])
if(set.contains(rev)->count++
else -> set.add(words[i])

for reverseing make a StringBuilder
sb.reverse()
return sb.toString()

HASHMAP:
-type of data structure
-insert,remove,search->TC:O(1)
-pairs are inserted

import java.util.HashMap;
public class maps
{
public static void main(String[]args)
{
HashMap<String,Integer> map=new HashMap<>();
map.add("Ishika",20);
map.add("Rishi",24);
-key and value 
System.out.print(map);
System.out.print(map.conatainsKey("Ishika"));//true
System.out.print(map.containsValue(20)); //true
map.put("Rishi",25); //overrides the existing key values
map.put("Riya",20); //valid 
-every map will have unique key but the value can be repeated
map.remove("Riya"); //removes the pair
map.size();
map.get(key) //give the value of that key
System.out.print(map.get("Ishika");//20

//traversing in HashMap
map.keySet()-> contains key
//can we can fetch values using the keys
for(String key:map.keySet())
{
System.out.print(key + map.get(key));
}
for(Object pair: map.entrySet())
{
System.out.print(pair);
}
}}


2Sum:
arr:{2,5,9,4} target=9
-crete hashmap ->ele,index store
-remianing val=target-ele(arr[i])
search in the hashmap

TREESETS AND TREEMAPS
-treeset and treemaps are alsways sorted
TreeSet<Integer> set= new TreeSet<>();
-these are balance BST.
-TreeMap<String,Integer> map= new TreeMap<>(); //sorted on the basis of dictionary and ascii values

//leetcode 1497:
-hashmap
-(7,8)-> divisible by 8
-(a+b)% k==0 =>if a%k +b%k=0
-travel in the arr => arr[i]%k
-go to your map => add arr[i]%k to hashmap
-travel in the map and search k-arr[i] that exist in map check there freq if the freq is noteqal then cannot be pair up return false


Question:
Leetcode 2442
Leetcode 2744
Leetcode 1
Leetcode 1207
Leetcode 3
Leetcode 2094
Leetcode 1497
