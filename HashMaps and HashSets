HASHSET
-type of datastructure
-TC:O(1):searching

import java.util.HashSet;
public class basic
{
public static void main(String[]args)
{
HashSet<Integer> set = new HashSet<>(); //this integer is a wrapper class of int
set.add(10);
set.add(20);
set.add(30);
//adding TC:O(1)
System.out.println(set);
//the elements are inserted in random order inside the set
//printed in random order
//search an element
System.out.print(set.contains(10)); // return true or false //TC:O(1)
System.out.print(set.size()); //3 TC:O(1)
set.remove(30);  //TC:O(1)
System.out.print(set); //10,20
Object[] arr= set.toArray();
for(int i=0;i<arr.length;i++)
{
  System.out.print(arr[i]+"");
}}}

For iteration in Hashset: using for each loop
for(int ele:set)
{
 System.out.print(ele);
set.add(30); //not possible 
}
//during iteration we cannnot add or remove elements
set.clear();  //empty set
//in hashset, occurance of any element is 1
//no element is repeated in set

HashSet<String> srt= new HashSet<>();

find max reverse pairs:
make a set
make a variable count
iterate in words see for each rev=reverse(words[i])
if(set.contains(rev)->count++
else -> set.add(words[i])

for reverseing make a StringBuilder
sb.reverse()
return sb.toString()

HASHMAP:
-type of data structure
-insert,remove,search->TC:O(1)
-pairs are inserted

import java.util.HashMap;
public class maps
{
public static void main(String[]args)
{
HashMap<String,Integer> map=new HashMap<>();
map.add("Ishika",20);
map.add("Rishi",24);
-key and value 
System.out.print(map);
System.out.print(map.conatainsKey("Ishika"));//true
System.out.print(map.containsValue(20)); //true
map.put("Rishi",25); //overrides the existing key values
map.put("Riya",20); //valid 
-every map will have unique key but the value can be repeated
map.remove("Riya"); //removes the pair
map.size();
map.get(key) //give the value of that key
System.out.print(map.get("Ishika");//20

//traversing in HashMap
map.keySet()-> contains key
//can we can fetch values using the keys
for(String key:map.keySet())
{
System.out.print(key + map.get(key));
}
for(Object pair: map.entrySet())
{
System.out.print(pair);
}
}}


2Sum:
arr:{2,5,9,4} target=9
-crete hashmap ->ele,index store
-remianing val=target-ele(arr[i])
search in the hashmap

TREESETS AND TREEMAPS
-treeset and treemaps are alsways sorted
TreeSet<Integer> set= new TreeSet<>();
-these are balance BST.
-TreeMap<String,Integer> map= new TreeMap<>(); //sorted on the basis of dictionary and ascii values

//leetcode 1497:
-hashmap
-(7,8)-> divisible by 8
-(a+b)% k==0 =>if a%k +b%k=0
-travel in the arr => arr[i]%k
-go to your map => add arr[i]%k to hashmap
-travel in the map and search k-arr[i] that exist in map check there freq if the freq is noteqal then cannot be pair up return false

Top view of Binary Search
-for every vertical level choose the top most element
-BFS used
-preorder cannot be used becaz it is depth first search hence while coming down the lowermost element will be called first
-make a Hashmap at which vertical element is the element is stored
-Queue for BFS
Queue<Node,level>
-apply BFs and then while removing the element check if map.containskey(ele)->if not then add map
-add Left child and right child
-the level of left child= curr level-1
-right child level= curr level+1

public static class Pair
    {
        TreeNode node;
        int level;
        Pair(TreeNode node,int level)
        {
            this.node=node;
            this.level=level;
        }
    }
public static void topView(TreeNode root)
{
    //level and node value
    HashMap<Integer,Integer> map=new HashMap<>();
    Queue<Pair> q= new LinkedList<>();
    Pair r = new Pair(root,0);
    int minLevel=Integer.MAX_VALUE;
    int maxLevel=Integer.MIN_VALUE;
    q.add(r);
    while(q.size()>0)
        {
            Pair temp=q.remove();
            TreeNode node=temp.node;
            int lvl=temp.level;
            minLevel=Math.min(minLevel,lvl);
            maxLevel=Math.max(maxLevel,lvl);
            if(!map.containsKey(lvl))
            {
                map.put(lvl,node.data);
            }
            if(node.left!=null) q.add(new Pair(node.left,lvl-1);
            if(node.right!=null) q.add(new PAir(node.right,lvl+1);
        }
    for(int =minLevel;i<=maxLevel;i++)
        {
            System.out.print(map.get(i)+"");

        }
}




Question:
Leetcode 2442
Leetcode 2744
Leetcode 1
Leetcode 1207
Leetcode 3
Leetcode 2094
Leetcode 1497
