Types of Trees:
   Generic Tree: any node in this tree can have any number of child nodes
   Binary Tree: any node can have 0,1,2 children
   Binary Search Tree: the left child nodes are smaller than root node, the right child node are bigger than root node
   AVL Tree: BST which are self balanced

Creation of Tree:
  class Node
{
 int val;
 Node left;
 Node right;
 Node(int val)
{
this.val=val;
}
}
public class basic
{
 Node a= new Node(1);
 Node b= new Node(2);
 Node c= new Node(3);
 a.left=b;
 a.right=c;
}

Display BST:
 private static display(Node root)
 {
 if(root==null) return;
System.out.print(root.val);
display(root.left);
display(root.right);
}

Find Sum of roots:
 private static int sum(Node root)
 {
 if(root==null) return 0;
 return root.val+sum(root.left)+ sum(root.right);
 }

Find product of TreeNode:
private static int product(Node root)
{
if(root==null) return; //Base case: if the node is null, return 1 
if(root.val==0) return 0;
return root.val* product(root.left)* product(root.right);
}

Find product of non zero elements of node
private static int product(Node root)
{
if(root==null) return 1;
if(root.val!=0)
{
 return root.val *product(root.left)*product(root.right);
}
else
{
return product(root.left)*product(root.right);
}
}

Find the node with maximum value:
//max can be either root node,root.left,rot.right
private staic max(Node root)
{
if(root==null) return Integer.MIN_VALUE;
int a=root.val;
int b= max(root.left);
int c= max(root.right);
return Math.max(a,Math.max(b,c));
}

Find the node with minimum value:
private static int min(Node root)
{
if(root==null) return Integer.MAX_VALUE;
int a=root.val;
int b=min(root.right);
int c=min(root.left);
return Math.min(a,Math.min(b,c));
}

Find the size of Binary Tree:
//no. of nodes
private int size(Node root)
{
if(root==null) return;
return 1 +size(root.left)+size(root.right);
}

SIZE:No of nodes
No. of edges:size-1
LEVEL: generations in family
HEIGHT: level-1

Find levels of Binary Tree
private static int levels(Node root)
{
if(root==null) return 0;
//becaz there is a possiblity that the tree might have only one child node
return 1+ Math.max(levels(root.left),levels(root.right));
}

TRAVERSALS:
1) BFS TRAVERSALS
Preoder:Root Left Right
Leetcode 144
private static void preorder(Noderoot)
{
if(root==null)return;
System.out.print(root.val+"");
preorder(root.left);
preorder(root.right);
}

Inorder:Left Root Right
Leetcode 94
private static void inorder(Node root)
{
if(root==null) return;
inorder(root.left);
System.out.print(root.val+"");
inorder(root.right);
}

Postorder: Left Right Root
Leetocode 145
private static void postorder(Node root)
{
if(root==null) return;
postorder(root.left);
postorder(root.right);
System.out.print(root.val+"");
}

reverse preorder root right left
reverse inorder right root left
reverse postorder right left root

2nd method of Traversal: pre in post(2 calls and printing)

1)Invert a Binary Tree=>Leetcode 226
swapping and recursive call

2)Same Tree=>Leetcode 100
both nodes are null
any one of them is null
the values are not equal
recursively call left and right nodes

3)Diameter of Binary Tree =>Leetcode 543
diameter= levels(LST)+levels(RST) //if it passes through the root
//if not neccesarily passing throught the root then:
recursively check for each node and return the maximum diameter among the left, right and the root diameter.

4)Lowest common Ancestor
check where is p and qq is lying
case1:  root==null: return null
case2:  root==p || root==q return root
recursivelt check for left and right
if(left!=null && right!=null) return root
return (left!=null)?left:right




